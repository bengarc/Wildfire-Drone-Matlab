clear; clc; close all;


numDrones       = 5;
n               = 30;     
maxSteps        = 300000;
stopThresh      = 0.1;    
k_decay         = 0.08;   
w_ax            = 0.006;   
w_diag          = w_ax/sqrt(2);  
radiusDrop      = 1;      
neighborFactor  = 0.25;  
rng(1);                   


Fire = zeros(n);
Int  = 1;

randNum1 = randi([1, n]);
randNum2 = randi([1, n]);
Fire(randNum1, randNum2) = Int;   

ctr = 1;
while randNum1 - ctr ~= 0
    Fire(randNum1 - ctr, randNum2) = Int*exp(-ctr/10);
    ctr = ctr + 1;
end

ctr = 1; 
while randNum1 + ctr ~= n+1
    Fire(randNum1 + ctr, randNum2) = Int*exp(-ctr/10);
    ctr = ctr + 1;
end

ctr = 1; 
while randNum2 + ctr ~= n+1
    Fire(randNum1, randNum2 + ctr) = Int*exp(-ctr/10);
    ctr = ctr + 1;
end

ctr = 1; 
while randNum2 - ctr ~= 0
    Fire(randNum1, randNum2 - ctr) = Int*exp(-ctr/10);
    ctr = ctr + 1;
end


ctr1 = 1; ctr2 = 1; 
while randNum1 - ctr1 ~= 0 && randNum2 - ctr2 ~= 0
    Fire(randNum1 - ctr1, randNum2 - ctr2) = Int*exp(-ctr1/10);
    ctr1 = ctr1 + 1; ctr2 = ctr2 + 1;
end
ctr1 = 1; ctr2 = 1; 
while randNum1 - ctr1 ~= 0 && randNum2 + ctr2 ~= n+1
    Fire(randNum1 - ctr1, randNum2 + ctr2) = Int*exp(-ctr1/10);
    ctr1 = ctr1 + 1; ctr2 = ctr2 + 1;
end
ctr1 = 1; ctr2 = 1; 
while randNum1 + ctr1 ~= n+1 && randNum2 - ctr2 ~= 0
    Fire(randNum1 + ctr1, randNum2 - ctr2) = Int*exp(-ctr1/10);
    ctr1 = ctr1 + 1; ctr2 = ctr2 + 1;
end
ctr1 = 1; ctr2 = 1; 
while randNum1 + ctr1 ~= n+1 && randNum2 + ctr2 ~= n+1
    Fire(randNum1 + ctr1, randNum2 + ctr2) = Int*exp(-ctr1/10);
    ctr1 = ctr1 + 1; ctr2 = ctr2 + 1;
end


for ii = 1:n
    for kk = 1:n
        if Fire(ii, kk) == 0
            Fire(ii, kk) = max(Fire(:,kk)) * 0.7;
            Fire(ii, kk) = max(Fire(ii,:)) * 0.7;
        end
    end
end
Fire = min(max(Fire,0),1);


drones = struct('id', {}, 'pos', {}, 'proposed', {}, 'target', {});
occupied = false(n,n);

for i = 1:numDrones
    placed = false;
    while ~placed
        r = randi([1,n]); c = randi([1,n]);
        if ~occupied(r,c)
            occupied(r,c) = true;
            drone.id       = i;
            drone.pos      = [r,c];
            drone.proposed = [r,c];
            drone.target   = [r,c];
            drones(i) = drone; 
            placed = true;
        end
    end
end


for i = 1:numDrones
    drones(i).extinguished = 0;   
    drones(i).dist         = 0;   
    drones(i).steps        = 0;   
    drones(i).nearMiss     = 0;   
end


disp("Drone Array Initialized:");
for i = 1:numDrones
    fprintf("Drone %d Start Position: [%d,%d]\n", ...
        drones(i).id, drones(i).pos(1), drones(i).pos(2));
end


figure;
imagesc(Fire, [0 1]); colormap(hot); axis equal tight;
title('Initial Fire Intensity with Drone Positions'); hold on;
for i = 1:numDrones
    pos = drones(i).pos;
    plot(pos(2), pos(1), 'ws', 'MarkerFaceColor','w', 'MarkerSize', 8);
    text(pos(2), pos(1), num2str(drones(i).id), ...
        'Color','k','FontWeight','bold','HorizontalAlignment','center');
end
hold off;


figure; colormap(hot);
for step = 1:maxSteps
    
     
    Fire = Fire .* exp(-k_decay);                                 
    Fire = min(max(Fire,0),1);                                    

    
    [tr, tc] = hottest_cell_original(Fire);

    
    for i = 1:numDrones
        drones(i).target   = [tr, tc];
        drones(i).proposed = step_one(drones(i).pos, drones(i).target, n);
    end

   
    drones = avoid_collision(drones, n);

   
   for i = 1:numDrones
    oldPos = drones(i).pos;
    newPos = drones(i).proposed;

    
    stepDist = abs(newPos(1)-oldPos(1)) + abs(newPos(2)-oldPos(2));
    drones(i).dist  = drones(i).dist + stepDist;
    drones(i).steps = drones(i).steps + 1;

    drones(i).pos = newPos;

 
    if Fire(newPos(1), newPos(2)) > 0
        drones(i).extinguished = drones(i).extinguished + 1;
        Fire = waterToFire(Fire, newPos, radiusDrop, neighborFactor);
    end
end


    
    imagesc(Fire, [0 1]); axis equal tight; hold on
    for i = 1:numDrones
        pos = drones(i).pos;
        plot(pos(2), pos(1), 'ws', 'MarkerFaceColor','w', 'MarkerSize', 8);
        text(pos(2), pos(1), num2str(drones(i).id), ...
            'Color','k','FontWeight','bold','HorizontalAlignment','center');
    end
    title(sprintf('Step %d | max(I)=%.3f', step, max(Fire,[],'all')))
    hold off; drawnow limitrate

    
    if max(Fire,[],'all') < stopThresh
        fprintf('Stopped at step %d (max intensity < %.2f)\n', step, stopThresh);
        break
    end
end


allProps = zeros(numDrones,2);
for i = 1:numDrones
    allProps(i,:) = drones(i).proposed;
end
for i = 1:numDrones
    dup = ismember(allProps, allProps(i,:), 'rows');
    if sum(dup) > 1
        drones(i).nearMiss = drones(i).nearMiss + 1;
    end
end



function drones = avoid_collision(drones,n)
    occupy = false(n,n);
    [~,order] = sort([drones.id],'ascend');
    for k = 1:numel(order)
        i = order(k);
        p = drones(i).proposed;
        p(1) = max(1,min(n,round(p(1))));
        p(2) = max(1,min(n,round(p(2))));
        if ~occupy(p(1),p(2))
            occupy(p(1),p(2)) = true;
            drones(i).proposed = p;
        else
            currentPos = drones(i).pos;
            drones(i).proposed = currentPos;      
            occupy(currentPos(1),currentPos(2)) = true;
        end
    end
end


function [tr, tc] = hottest_cell_original(I)
    
    if ~any(I(:))
        tr = 1; tc = 1; return;
    end
    [~,idx] = max(I(:));
    [rows,~] = size(I);
    tc = mod(idx-1,rows) + 1;                  
    tr = floor((idx-1) / rows) + 1;            
end


function next = step_one(pos,tgt,n)
    r = pos(1); c = pos(2);
    tr = tgt(1); tc = tgt(2);
    if r < tr
        r = r + 1;
    elseif r > tr
        r = r - 1;
    elseif c < tc
        c = c + 1;
    elseif c > tc
        c = c - 1;
    end
    r = max(1,min(n,r));
    c = max(1,min(n,c));
    next = [r,c];
end


function I = waterToFire(I, center, radius, neighborFactor)
    n = size(I,1);
    r0 = center(1); c0 = center(2);
    rmin = max(1, r0 - radius); rmax = min(n, r0 + radius);
    cmin = max(1, c0 - radius); cmax = min(n, c0 + radius);

    I(r0, c0) = 0;  

    for rr = rmin:rmax
        for cc = cmin:cmax
            if ~(rr==r0 && cc==c0)
                I(rr, cc) = neighborFactor * I(rr, cc);
            end
        end
    end
end

ids           = [drones.id]';
extinguished  = [drones.extinguished]';
distance      = [drones.dist]';
stepsActive   = [drones.steps]';
nearMisses    = [drones.nearMiss]';
efficiency    = extinguished ./ max(distance,1);

Summary = table(ids, extinguished, distance, stepsActive, nearMisses, efficiency, ...
    'VariableNames', {'DroneID','Extinguished','Distance','Steps','NearMisses','Efficiency'});

disp('=== FINAL SUMMARY TABLE ===');
disp(Summary);

writetable(Summary,'summary.csv');
save('run_data.mat','Fire','drones','n','maxSteps','stopThresh','k_decay','w_ax','w_diag','radiusDrop','neighborFactor');

[~, idxTopExt] = max(extinguished);
[~, idxTopEff] = max(efficiency);
[~, idxTopDist]= max(distance);

fprintf('\n=== INTERPRETATION BULLETS ===\n');
fprintf('• Drone %d extinguished the most cells (%d).\n', ids(idxTopExt), extinguished(idxTopExt));
fprintf('• Drone %d was most efficient (%.3f cells per unit distance).\n', ids(idxTopEff), efficiency(idxTopEff));
fprintf('• Drone %d traveled the farthest (distance = %d).\n', ids(idxTopDist), distance(idxTopDist));
if any(nearMisses>0)
    [~, idxMostNM] = max(nearMisses);
    fprintf('• Drone %d had the most contested moves (%d near-misses), showing collision avoidance engaged often.\n', ...
        ids(idxMostNM), nearMisses(idxMostNM));
end
fprintf('• Simulation ended when max intensity dropped below %.2f.\n', stopThresh);




